# “Massive Storage”第二届大学生信息存储技术竞赛·挑战赛

## 开发环境要求：
Ubuntu  ≥ 	18.04
cmake	≥  	3.27.5
make	≥ 	4.1
GCC		≥ 	7.5

## 编译运行

```shell
# 命令
cd project_hw
mkdir build
cd build
cmake ..
make
../bin/project_hw -f ../test/dataset/case_1.txt
```

```shell
cd build
rm -rf *
cmake ..
make
../bin/project_hw -f ../test/dataset/case_1.txt
```

## 项目目录结构
```
...
```

## 测试
### 初步测试 
每列表示:对应算法的结果的 寻址时间(ms)，除先入先出算法，另外算法采用LKH2，问题类型ATSP，参数为默认值
| 算例     | 先入先出   | 无虚拟结点 |  虚拟结点 | 虚拟+考虑磁头 |
|----------|-----------|-----------|----------|--------------|
| case1    |  1362738  |  623643   |  354295  |    354295    |
| case2    |  850195   |  429979   |  293696  |    293696    |
| case3    |  1003042  |  545996   |  495332  |    355182    |
| case4    |  3859545  |  676173   |  685706  |    626477    |
| case5    |  7664161  |  1082234  |  996508  |    885576    |

---

### 换LKH3, 其实在这个问题上感觉用LKH2或3没啥差别

### 10月6日:
ascent中使用子梯度优化，记采用 Ascent 为 A（先ascent后启发式），不采用 Ascent 为 B(即直接启发式)  
| 算例      |  IO 数量  | 总时间限制 | Ascent时间| 初始Cost(A)  | 结束Cost(A)       | 初始Cost(B)| 结束Cost(B)    |  
|----------|-----------|-----------|-----------|-----------   |------------------ |------------|---------------|
| case20   |  10       |  20s      |  0.00s    |  311985(精确)|        -          | 372754     | 325274(run=4 end)|
| case80   |  50       |  20s      |  0.01s    |  657837      |  657837(0.00s)    | 3951869    |677259(run=10) |
| case5    |  90       |  20s      |  0.02s    |  885576      |  885576(0.00s)    | 7433988    |960172(run=10) |
| case100  |  100      |  20s      |  0.03s    |  962238      |  905808(0.00s)    | 8931135    |1002438(run=10)|
| case150  |  1000     |  20s      |  3s       |  2884045     |  2884027(3s)      | 80453705   |3144666(run=5) |
| case200  |  2000     |  20s      |  16s      |  4947756     |  4246606          | 158915229  |13214868(run=1)|
| case245  |  5000     |  300s     |  221s     |  13382658    |  6639884          | 92080589   |10026902       |
| case285  |  10000    |  inf      |  6493s    |  11280991    |  8741567(11999s)  | 359416893  |322422444(60s) |
发现：
1. ascent的作用是巨大的，ascent结束后得到的初始解就比较优，后续也能通过启发式继续优化
2. 目前看 io <= 2000 的算例都能在20s内ascent成功
3. 每次run结果一样的原因：因为在第一次run就抵达了局部最优；而直接启发式的时候，每次run都是有改进的
4. 直接启发式的话，初始解通常很差，搜索20s后其解仍比较差，比不上先ascent后启发式，甚至比不上ascent得到的初始解
5. 直接启发式，一般得不到精确解，会卡在局部最优，比如case20，在run=4得到局部最优，后续run再无法改进
结论：
1. io <= 2000 的算例直接 ascent 后启发式就行，如果20s前启发式改进幅度大于调度加分，继续搜索（tip:一般继续搜索更好？）；  
    如果20s后启发式的改进幅度仍大于超时惩罚，可以允许继续搜索（tip:超时罚分还是比较大的）
2. 大算例比如 io >= 5000, 先ascent是不可取的，因为超时惩罚无法接受，比如case245，跑300s将得到负分；  
    直接启发式20s内可以得到比基线更好的解，比如case245，直接启发式20s得到的解对比于scan提升幅度是400%
3. 超大算例，io = 10000, 直接启发式也是不可取了，因为20s跑出的结果比基线还差
4. 还是得尝试划分子问题，看解是否比直接启发式更好

### 10月7日 新发现
ascent中使用POPMUSIC生成候选集，而不用子梯度优化  
| 算例      |  IO 数量  | 总时间限制 | Ascent时间|   初始Cost   |       结束Cost    | 
|----------|-----------|-----------|-----------|--------------|------------------ |
| case20   |  10       |  20s      |  0.00s    |  311985(精确)|        -          |
| case80   |  50       |  20s      |  0.03s    |  657837      |  657837(0.00s)    |
| case5    |  90       |  20s      |  0.03s    |  885576      |  885576(0.00s)    |
| case100  |  100      |  20s      |  0.05s    |  905808      |  905808(0.00s)    |
| case150  |  1000     |  20s      |  0.8s     |  2918033     |  2886032          |
| case200  |  2000     |  20s      |  2.3s     |  4521253     |  4255691          |
| case245  |  5000     |  20s      |  10.27s   |  6601191     |  6374933          |
| case285  |  10000    |  60s      |  38.33s   |  11238502    |  10715782         |
发现：
1. 震惊我了，不愧是线性时间复杂度啊，怪不得能单独发论文
2. 在 io <= 2000 时，最终结果和子梯度优化不相上下；   
   在 io > 2000 时，完爆子梯度优化，无论是时间上还是最终结果上。
3. 虽然它很快，但是它生成的候选集的质量应该是稍微逊色于子梯度优化一筹，  
   所以在中等算例上，子梯度优化后的启发式的收敛速度更快，比如case150，  
   启发式搜索了3s就收敛到局部最优，而此处搜索了19s仍未收敛，这可以赚点调度加分（待进一步验证）  
4. 此外，我验证了令参数 POPMUSIC_Solutions = 25; 即默认值减半，发现IO为10000的也能20秒ascent完，  
   且因为没超时，最终分数还会高些
结论：
1. 大规模算例就该使用 POPMUSIC
2. 其次，可以比较一下各种较小规模io下，是采用子梯度优化更优还是POPMUSIC更优