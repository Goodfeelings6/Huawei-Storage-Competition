# “Massive Storage”第二届大学生信息存储技术竞赛·挑战赛

## 开发环境要求：
Ubuntu  ≥ 	18.04
cmake	≥  	3.27.5
make	≥ 	4.1
GCC		≥ 	7.5

## 编译运行

```shell
# 命令
cd project_hw
mkdir build
cd build
cmake ..
make
../bin/project_hw -f ../test/dataset/case_285.txt
```

```shell
cd build
rm -rf *
cmake ..
make
../bin/project_hw -f ../test/dataset/case_285.txt
```

## 项目目录结构
```
...
```

## 探索与测试
### 初步测试 
每列表示:对应算法的结果的 寻址时间(ms)，除先入先出算法，另外算法采用LKH2，问题类型ATSP，参数为默认值
| 算例     | 先入先出   | 无虚拟结点 |  虚拟结点 | 虚拟+考虑磁头 |
|----------|-----------|-----------|----------|--------------|
| case1    |  1362738  |  623643   |  354295  |    354295    |
| case2    |  850195   |  429979   |  293696  |    293696    |
| case3    |  1003042  |  545996   |  495332  |    355182    |
| case4    |  3859545  |  676173   |  685706  |    626477    |
| case5    |  7664161  |  1082234  |  996508  |    885576    |

---

### 换LKH3, 其实在这个问题上感觉用LKH2或3没啥差别
---
### 10月6日:
ascent中使用子梯度优化，记采用 Ascent 为 A（先ascent后启发式），不采用 Ascent 为 B(即直接启发式)  
| 算例      |  IO 数量  | 总时间限制 | Ascent时间| 初始Cost(A)  | 结束Cost(A)       | 初始Cost(B)| 结束Cost(B)    |  
|----------|-----------|-----------|-----------|-----------   |------------------ |------------|---------------|
| case20   |  10       |  20s      |  0.00s    |  311985(精确)|        -          | 372754     | 325274(run=4 end)|
| case80   |  50       |  20s      |  0.01s    |  657837      |  657837(0.00s)    | 3951869    |677259(run=10) |
| case5    |  90       |  20s      |  0.02s    |  885576      |  885576(0.00s)    | 7433988    |960172(run=10) |
| case100  |  100      |  20s      |  0.03s    |  962238      |  905808(0.00s)    | 8931135    |1002438(run=10)|
| case150  |  1000     |  20s      |  3s       |  2884045     |  2884027(3s)      | 80453705   |3144666(run=5) |
| case200  |  2000     |  20s      |  16s      |  4947756     |  4246606          | 158915229  |13214868(run=1)|
| case245  |  5000     |  300s     |  221s     |  13382658    |  6639884          | 92080589   |10026902       |
| case285  |  10000    |  inf      |  6493s    |  11280991    |  8741567(11999s)  | 359416893  |322422444(60s) |  

发现：
1. ascent的作用是巨大的，ascent结束后得到的初始解就比较优，后续也能通过启发式继续优化
2. 目前看 io <= 2000 的算例都能在20s内ascent成功
3. 每次run结果一样的原因：因为在第一次run就抵达了局部最优；而直接启发式的时候，每次run都是有改进的
4. 直接启发式的话，初始解通常很差，搜索20s后其解仍比较差，比不上先ascent后启发式，甚至比不上ascent得到的初始解
5. 直接启发式，一般得不到精确解，会卡在局部最优，比如case20，在run=4得到局部最优，后续run再无法改进
结论：
1. io <= 2000 的算例直接 ascent 后启发式就行，如果20s前启发式改进幅度大于调度加分，继续搜索（tip:一般继续搜索更好？）；  
    如果20s后启发式的改进幅度仍大于超时惩罚，可以允许继续搜索（tip:超时罚分还是比较大的）
2. 大算例比如 io >= 5000, 先ascent是不可取的，因为超时惩罚无法接受，比如case245，跑300s将得到负分；  
    直接启发式20s内可以得到比基线更好的解，比如case245，直接启发式20s得到的解对比于scan提升幅度是400%
3. 超大算例，io = 10000, 直接启发式也是不可取了，因为20s跑出的结果比基线还差
4. 还是得尝试划分子问题，看解是否比直接启发式更好

### 10月7日 新发现
ascent中使用POPMUSIC模式生成候选集，而不用 ALPHA模式+子梯度优化  
| 算例      |  IO 数量  | 总时间限制 | Ascent时间|   初始Cost   |       结束Cost    | 
|----------|-----------|-----------|-----------|--------------|------------------ |
| case20   |  10       |  20s      |  0.00s    |  311985(精确)|        -          |
| case80   |  50       |  20s      |  0.03s    |  657837      |  657837(0.00s)    |
| case5    |  90       |  20s      |  0.03s    |  885576      |  885576(0.00s)    |
| case100  |  100      |  20s      |  0.05s    |  905808      |  905808(0.00s)    |
| case150  |  1000     |  20s      |  0.8s     |  2918033     |  2886032          |
| case200  |  2000     |  20s      |  2.3s     |  4521253     |  4255691          |
| case245  |  5000     |  20s      |  10.27s   |  6601191     |  6374933          |
| case285  |  10000    |  60s      |  38.33s   |  11238502    |  10715782         |

发现：
1. 震惊我了，不愧是线性时间复杂度啊，怪不得能单独发论文
2. 在 io <= 2000 时，最终结果和子梯度优化不相上下（略差）；   
   在 io > 2000 时，无论是时间上还是最终结果上都优于 ALPHA模式+子梯度优化。
3. 虽然它很快，但是它生成的候选集的质量应该是稍微逊色于 ALPHA模式+子梯度优化 一筹，  
   所以在中等算例上，子梯度优化后的启发式的收敛速度更快，比如case150，  
   启发式搜索了3s就收敛到局部最优，而此处搜索了19s仍未收敛，这可以赚点调度加分（待进一步验证）  
4. 此外，我验证了令参数 POPMUSIC_Solutions = 25; 即默认值减半，发现IO为10000的也能20秒ascent完，  
   且因为没超时，最终分数还会高些
结论：
1. 大规模算例就该使用 POPMUSIC模式
2. 其次，可以比较一下各种较小规模io下，是采用 ALPHA模式+子梯度优化 更优还是POPMUSIC更优

### 10月8日 新发现
发现：
1. 最近邻算法得到的解就比较好，比SCAN好很多；**使用最近邻算法得到的解作为 LKH 的初始解，会使结果变好很多**，该初始解也应作为划分子问题时的依据
2. **划分子问题会使结果略差，但是能降低求解时间**，IO=10000的算例划分为4个子问题较佳


### 10月10日 
### 回退使用LKH2, 并拷贝到 LKH2_MIN, 在其中任意修改
---
#### 中阶算例 POP_MUSIC Ascent Time 统计
| 算例     |  IO 数量    |Ascent Time| 初始Cost  |  结束Cost |
|----------|------------|-----------|-----------|-----------|
| case180  |  2000      |  2.18s    |  4129929  |  4052588  |
| case420  |  3000      |  4.24s    |  5023292  |  4981325  |
| case460  |  4000      |  6.91s    |  5843256  |  5777847  |
| case230  |  5000      |  9.98s    |  6709219  |  6641096  |
| case500  |  6000      |  14.23s   |  6985376  |  6962341  |
| case540  |  7000      |  17.91s   |  7802182  |  7786246  |

#### 策略设计
1. 启发式搜索跳出策略：改进幅度小于调度用时加分时尽快跳出，其次尽量不超时。
   + 当前总用时<20s时，若timeSpan秒（timeSpan是个参数，可以设置为<=2的值）内的改进得分大于timeSpan*10000，则继续搜索，否则退出；
   + 当前总用时>=20s时，立即退出。（因为极大概率罚分大于改进幅度）
2. 候选集的生成策略：能用ALPHA模式就用，时间捉襟见肘的话（还要考虑调度用时加分），就换为POP_MUSIC模式。
   + 当IO<=1750时，使用ALPHA模式生成候选集（IO=1750，ALPHA模式 Ascent Time 约为 10.5s）
   + 当IO>1750时，使用POP_MUSIC模式生成候选集
3. 子问题划分策略：能不划分就不划分，必须划分时则保证尽量少的划分（注意只支持等分，故每个子问题分配相同的时间）。
   + 当IO<=6000时，不划分子问题（IO=6000，POP_MUSIC模式 Ascent Time 约为 13.7s）
   + 当IO>6000时，划分子问题:（暂定：划分子问题后只完整求解一个轮次，因为完整执行第二轮的时间不够。**改进：IO<7000时，第二轮或许可以完成一部分**）
   + + 6000 < IO <= 7000时，划分为2个子问题
   + + 7000 < IO <= 9000时，划分为3个子问题
   + + IO > 9000时，划分为4个子问题

### 10月11日
租用华为云ECS鲲鹏通用计算增强型kc2, 2vCPU、4GB内存的服务器（比赛测试环境），简单试了下，服务器的运算速度跟10月10日的本地环境运算速度差不多，服务器还快一点点，因此10月10日设置的策略大体上没问题。

### 10月12日
+ 微调了LKH_MIN代码，使得每次求解必执行完一次Trial(即Trial==1时不判断时限来退出，注意每次Trial用时约<0.02s)，由此保证不会输出0序列；
+ 修改了SubProblemTotalTimeLimit的计算方式，每次执行子任务前都重新计算，这样可以将‘因前面子任务提前跳出而省下的时间’分配给后面的子任务使用。

### 10月13日 策略改进方向
经过深入阅读论文和实测，发现POP_MUSIC模式+少量次梯度优化也可以提升解质量，当然时间会增加，所以一个改进是当时间比较充裕时，通过增加次梯度优化的量，来达到更好的解。这个改进可以聚焦于 1750 < IO <= 6000 的规模，更大的规模时间就比较紧张了。

## 调参与测试
### 10月14日
#### 增量节点0：采用10月10日策略+默认参数
[增量节点0](./test/调参增量节点/增量节点0)
|   算例   |  IO数量 |子问题数 | Ascent时间|局部搜索最多用时|  最终Cost |
|----------|--------|---------|----------|---------------|----------|
|  case_5  |   90   |    1    |  0.02s   |      0s       |  885576  |
| case_20  |   10   |    1    |  0.00s   |      0s       |  311985  |
| case_80  |   50   |    1    |  0.01s   |     0.01s     |  657837  |
| case_100 |  100   |    1    |  0.04s   |     0.00s     |  905808  |
| case_150 |  1000  |    1    |  3.27s   |     2.29s     | 2884027  |
| case_200 |  2000  |    1    |  1.97s   |     6.04s     | 4240458  |
| case_245 |  5000  |    1    |  10.90s  |     8.24s     | 5784630  |
| case_285 | 10000  |    4    |  3.22s   |     0.98s     | 9048322  |
| case_290 |  1350  |    1    |  5.51s   |     4.00s     | 3208503  |
| case_300 |  1500  |    1    |  7.08s   |     4.01s     | 3520424  |
| case_305 |  1750  |    1    |  9.87s   |     4.01s     | 3427710  |
| case_310 |  3000  |    1    |  4.02s   |    12.07s     | 4981597  |
| case_320 |  4000  |    1    |  6.82s   |    12.12s     | 5782089  |
| case_330 |  6000  |    1    |  15.14s  |     3.67s     | 7145686  |
| case_335 |  7000  |    2    |  5.52s   |     3.67s     | 6808325  |
| case_345 |  8000  |    3    |  3.50s   |     2.43s     | 7631988  |
| case_355 |  9000  |    3    |  4.27s   |     1.52s     | 8032370  |
| case_365 |  9500  |    4    |  2.96s   |     1.32s     | 7753174  |

#### 增量节点1：增量节点0+moveType从5改为3
[增量节点1](./test/调参增量节点/增量节点1)
|   算例   |  IO数量 |子问题数 | Ascent时间|局部搜索最多用时|  最终Cost |
|----------|--------|------- -|----------|---------------|----------|
|  case_5  |   90   |    1    |  0.02s   |      0s       |  885576  |
| case_20  |   10   |    1    |  0.00s   |      0s       |  311985  |
| case_80  |   50   |    1    |  0.01s   |     0.01s     |  657837  |
| case_100 |  100   |    1    |  0.04s   |     0.00s     |  905808  |
| case_150 |  1000  |    1    |  3.32s   |     1.97s     | 2884027  |
| case_200 |  2000  |    1    |  2.02s   |    14.07s     | 4218082  |
| case_245 |  5000  |    1    |  10.82s  |     8.14s     | 5749312  |
| case_285 | 10000  |    4    |  3.25s   |     0.96s     | 9029224  |
| case_290 |  1350  |    1    |  5.72s   |     4.00s     | 3208503  |
| case_300 |  1500  |    1    |  7.13s   |     4.00s     | 3520424  |
| case_305 |  1750  |    1    |  9.79s   |     4.01s     | 3426773  |
| case_310 |  3000  |    1    |  3.93s   |     8.07s     | 4984098  |
| case_320 |  4000  |    1    |  6.98s   |     8.13s     | 5785633  |
| case_330 |  6000  |    1    |  14.93s  |     3.87s     | 7079822  |
| case_335 |  7000  |    2    |  5.47s   |     3.72s     | 6769425  |
| case_345 |  8000  |    3    |  3.48s   |     2.65s     | 7626040  |
| case_355 |  9000  |    3    |  4.30s   |     1.50s     | 8023319  |
| case_365 |  9500  |    4    |  2.94s   |     1.32s     | 7732121  |  

分析：IO<=1500时，平局；此外除IO=3000,4000的变差几千，其余都是提升，其中1750的有千级提升，其余均有万级提升  
原因：...  
策略：所有规模均采用 moveType = 3    

#### 增量节点2：增量节点1+AscentCandidates从50改为25
[增量节点2](./test/调参增量节点/增量节点2)
|   算例   |  IO数量 |子问题数 | Ascent时间|局部搜索最多用时|  最终Cost |
|----------|--------|---------|----------|---------------|----------|
|  case_5  |   90   |    1    |  0.01s   |     0.01s     |  885576  |
| case_20  |   10   |    1    |  0.00s   |      0s       |  311985  |
| case_80  |   50   |    1    |  0.01s   |     0.01s     |  657837  |
| case_100 |  100   |    1    |  0.03s   |     0.00s     |  905808  |
| case_150 |  1000  |    1    |  1.96s   |     3.62s     | 2884027  |
| case_200 |  2000  |    1    |  1.99s   |    12.05s     | 4224370  |
| case_245 |  5000  |    1    |  10.66s  |     8.49s     | 5753431  |
| case_285 | 10000  |    4    |  3.21s   |     1.01s     | 9001178  |
| case_290 |  1350  |    1    |  3.88s   |     4.00s     | 3208577  |
| case_300 |  1500  |    1    |  5.42s   |     4.01s     | 3525280  |
| case_305 |  1750  |    1    |  11.58s  |     4.01s     | 3427427  |
| case_310 |  3000  |    1    |  3.91s   |     8.07s     | 4990047  |
| case_320 |  4000  |    1    |  6.92s   |     6.09s     | 5782861  |
| case_330 |  6000  |    1    |  15.01s  |     3.86s     | 7075477  |
| case_335 |  7000  |    2    |  5.58s   |     3.66s     | 6775982  |
| case_345 |  8000  |    3    |  3.49s   |     2.46s     | 7622916  |
| case_355 |  9000  |    3    |  4.25s   |     1.55s     | 7998009  |
| case_365 |  9500  |    4    |  2.94s   |     1.33s     | 7728758  |

分析：有好有差，变动幅度也不大，千级
原因：...  
策略：所有规模均不采用  

#### 增量节点3：增量节点1+POPMUSIC_SampleSize从10到15+POPMUSIC_Solutions从50到15+POPMUSIC_Trials从1到3
[增量节点3](./test/调参增量节点/增量节点3)
|   算例   |  IO数量 |子问题数 | Ascent时间|局部搜索最多用时|  最终Cost |
|----------|--------|---------|----------|---------------|----------|
|  case_5  |   90   |    1    |  0.02s   |      0s       |  885576  |
| case_20  |   10   |    1    |  0.00s   |      0s       |  311985  |
| case_80  |   50   |    1    |  0.01s   |     0.01s     |  657837  |
| case_100 |  100   |    1    |  0.04s   |     0.00s     |  905808  |
| case_150 |  1000  |    1    |  3.46s   |     1.97s     | 2884027  |
| case_200 |  2000  |    1    |  0.70s   |     6.03s     | 4222865  |
| case_245 |  5000  |    1    |  3.62s   |     8.25s     | 5787982  |
| case_285 | 10000  |    4    |  1.29s   |     3.03s     | 8984782  |
| case_290 |  1350  |    1    |  5.74s   |     4.00s     | 3208503  |
| case_300 |  1500  |    1    |  7.42s   |     4.00s     | 3520424  |
| case_305 |  1750  |    1    |  9.67s   |     4.01s     | 3426846  |
| case_310 |  3000  |    1    |  1.44s   |    14.10s     | 4974368  |
| case_320 |  4000  |    1    |  2.34s   |    12.10s     | 5784531  |
| case_330 |  6000  |    1    |  4.87s   |    10.18s     | 7074405  |
| case_335 |  7000  |    2    |  2.15s   |     6.19s     | 6787111  |
| case_345 |  8000  |    3    |  1.37s   |     5.10s     | 7610332  |
| case_355 |  9000  |    3    |  1.64s   |     3.04s     | 7969800  |
| case_365 |  9500  |    4    |  1.21s   |     3.03s     | 7726309  |

分析：POPMUSIC的Ascent时间显著减少了，局部搜索时间增加了...
原因：...  
策略：...